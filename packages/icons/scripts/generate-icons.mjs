import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { transform } from "@svgr/core";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// packages/icons/scripts -> repo root
const repoRoot = path.resolve(__dirname, "..", "..", "..");
const assetsRoot = path.resolve(repoRoot, "assets", "svg");
const pkgRoot = path.resolve(repoRoot, "packages", "icons");
const outDir = path.resolve(pkgRoot, "src", "generated");
const indexFile = path.resolve(outDir, "index.ts");

const EXCLUDE_DIRS = new Set([
  "node_modules",
  ".git",
  "dist",
  "build",
  "coverage",
  "packages",
  "apps"
]);

function toPascalCase(input) {
  const parts = input
    .replace(/\.svg$/i, "")
    .replace(/^Property\s*1=/i, "") // common Figma export prefix
    .split(/[^a-zA-Z0-9]+/g)
    .filter(Boolean);

  const name = parts
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join("");

  if (!name) return "Icon";
  if (/^\d/.test(name)) return `Icon${name}`;
  return name;
}

function posixify(p) {
  return p.split(path.sep).join("/");
}

async function walk(dir, results) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const ent of entries) {
    const full = path.join(dir, ent.name);
    if (ent.isDirectory()) {
      if (EXCLUDE_DIRS.has(ent.name)) continue;
      await walk(full, results);
    } else if (ent.isFile() && ent.name.toLowerCase().endsWith(".svg")) {
      results.push(full);
    }
  }
}

async function main() {
  const svgFiles = [];
  await walk(assetsRoot, svgFiles);

  await fs.mkdir(outDir, { recursive: true });

  // Clear previous generated files
  const existing = await fs.readdir(outDir).catch(() => []);
  await Promise.all(
    existing.map((f) => fs.rm(path.join(outDir, f), { force: true }))
  );

  const usedComponentNames = new Map(); // name -> count
  const items = [];

  for (const svgAbsPath of svgFiles.sort()) {
    const relFromRepo = posixify(path.relative(repoRoot, svgAbsPath));
    const base = path.basename(svgAbsPath);
    const rawName = base.replace(/\.svg$/i, "");

    let componentName = toPascalCase(rawName);
    const count = usedComponentNames.get(componentName) ?? 0;
    usedComponentNames.set(componentName, count + 1);
    if (count > 0) componentName = `${componentName}${count + 1}`;

    const svgCode = await fs.readFile(svgAbsPath, "utf8");

    const tsx = await transform(
      svgCode,
      {
        typescript: true,
        icon: true,
        expandProps: "end",
        svgo: true,
        svgoConfig: {
          plugins: [
            {
              name: "preset-default",
              params: {
                overrides: {
                  // keep viewBox so icons scale properly
                  removeViewBox: false
                }
              }
            }
          ]
        }
      },
      { componentName }
    );

    const outFile = path.join(outDir, `${componentName}.tsx`);
    await fs.writeFile(outFile, tsx, "utf8");

    items.push({
      id: relFromRepo.replace(/\.svg$/i, ""),
      componentName,
      filePath: relFromRepo
    });
  }

  // Build index.ts
  const exportLines = [];
  exportLines.push("/**");
  exportLines.push(" * AUTO-GENERATED FILE â€” DO NOT EDIT");
  exportLines.push(" * Generated by: packages/icons/scripts/generate-icons.mjs");
  exportLines.push(" */");
  exportLines.push("");
  exportLines.push('import type { ComponentType, SVGProps } from "react";');
  exportLines.push("");

  for (const it of items) {
    exportLines.push(
      `export { default as ${it.componentName} } from "./${it.componentName}";`
    );
  }

  exportLines.push("");
  exportLines.push(
    "export type IconComponent = ComponentType<SVGProps<SVGSVGElement>>;"
  );
  exportLines.push("");

  exportLines.push("export const icons = {");
  for (const it of items) {
    exportLines.push(`  "${it.id}": ${it.componentName},`);
  }
  exportLines.push("} as const;");
  exportLines.push("");
  exportLines.push("export type IconName = keyof typeof icons;");
  exportLines.push("");
  exportLines.push("export const iconsMeta = [");
  for (const it of items) {
    exportLines.push(
      `  { id: "${it.id}", componentName: "${it.componentName}", filePath: "${it.filePath}" },`
    );
  }
  exportLines.push("] as const;");
  exportLines.push("");

  await fs.writeFile(indexFile, exportLines.join("\n"), "utf8");

  console.log(`Generated ${items.length} icon components.`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});


